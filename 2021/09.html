<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>AOC 2021 day 9</title>
    <script charset="utf-8">
      const Grid = function(cells) {
        this.cells = cells
        this.height = cells.length
        this.width = cells[0].length
      }

      Grid.prototype.neightboursPositions = function(row, col) {
        return [
          [row-1, col],
          [row+1, col],
          [row, col-1],
          [row, col+1]
        ].filter(([row, col]) => row >= 0 && col >= 0 && row < this.height && col < this.width)
      }

      Grid.prototype.neightbours = function(row, col) {
        return this.neightboursPositions(row, col).map(([row, col]) => this.cells[row][col])
      }

      Grid.prototype.lowPointsPositions = function() {
        const res = []

        for(let row=0; row<this.height; row++) {
          for(let col=0; col<this.width; col++) {
            let ns = this.neightbours(row, col)
            if(ns.every(n => n > this.cells[row][col])) {
              res.push([row, col])
            }
          }
        }

        return res
      }

      Grid.prototype.lowPoints = function() {
        return this.lowPointsPositions().map(([row, col]) => this.cells[row][col])
      }

      Grid.prototype.basinSizeTick = function(index) {
        const state = this.calculatingThreeLargestBasinSizesState

        const visited = state.visited[index]
        const queue = state.queue[index]
        const canvasCtx = state.canvasCtx
        const cellSize = state.cellSize

        if(queue.length === 0) {
          return
        }

        const [row, col] = queue.shift()

        if(!visited[[row, col]] && this.cells[row][col] < 9) {
          visited[[row, col]] = true
          const color = this.cells[row][col] * 25
          canvasCtx.fillStyle = "rgb(" + color + ", " + color + ", " + color + ")"
          canvasCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize)
          this.neightboursPositions(row, col).forEach(pos => {
            if(!visited[pos] && this.cells[pos[0]][pos[1]] < 9) {
              queue.push(pos)
            }
          })

          state.basinSizes[index]++
        }
      }

      Grid.prototype.prepareToCalculateThreeLargestBasinSizes = function() {
        const lowPointsPositions = this.lowPointsPositions()

        const canvas = document.getElementById("canvas")
        const canvasCtx = canvas.getContext("2d")
        const cellSize = Math.min(canvas.width / this.width, canvas.height / this.height)

        canvasCtx.fillStyle = "white"
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height)

        canvasCtx.fillStyle = "red"
        lowPointsPositions.forEach(([row, col]) => canvasCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize))

        this.calculatingThreeLargestBasinSizesState = {
          canvasCtx: canvasCtx,
          cellSize: cellSize,
          basinSizes: lowPointsPositions.map(_lpp => 0),
          visited: lowPointsPositions.map(_lpp => new Object()),
          queue: lowPointsPositions.map(lpp => [lpp])
        }
      }

      Grid.prototype.calculateThreeLargestBasinSizesTick = function() {
        const state = this.calculatingThreeLargestBasinSizesState

        for(let i=0; i<state.basinSizes.length; i++) {
          this.basinSizeTick(i)
        }
      }

      Grid.prototype.calculateThreeLargestBasinSizesDone = function() {
        const state = this.calculatingThreeLargestBasinSizesState

        return state.queue.every(q => q.length === 0)
      }

      Grid.prototype.threeLargestBasinSizes = function() {
        const state = this.calculatingThreeLargestBasinSizesState

        return state.basinSizes.sort((a, b) => b - a).slice(0, 3)
      }

      window.onload = function() {
        const solveButton = document.getElementById("solve")
        const inputTextarea = document.getElementById("input")
        const part1OutputSpan = document.getElementById("part-1-output")
        const part2OutputSpan = document.getElementById("part-2-output")

        solveButton.addEventListener("click", function() {
          part1OutputSpan.innerText = "Calculating..."
          part2OutputSpan.innerText = "Calculating..."

          const cells = inputTextarea.value.split("\n").map(row => row.split("").map(n => parseInt(n)))
          const grid = new Grid(cells)

          part1OutputSpan.innerText = (grid.lowPoints().map(lp => lp + 1).reduce((a, e) => a + e))
          grid.prepareToCalculateThreeLargestBasinSizes()

          let ticks = 0
          const tick = function() {
            if(ticks < 2) {
              ticks++
              requestAnimationFrame(tick)
            } else {
              ticks = 0
              if(grid.calculateThreeLargestBasinSizesDone()) {
                part2OutputSpan.innerText = (grid.threeLargestBasinSizes().reduce((a, e) => a * e))
              } else {
                grid.calculateThreeLargestBasinSizesTick()
                requestAnimationFrame(tick)
              }
            }
          }
          requestAnimationFrame(tick)
        })
      }
    </script>
  </head>
  <body>
    <label>input</label><br/>
    <textarea id="input" style="width: 600px; height: 100px">2199943210
3987894921
9856789892
8767896789
9899965678</textarea>
    <br/>
    <button id="solve">Solve!</button><br/>
    <br/>
    <label>part 1 solution:</label>
    <span id="part-1-output">-</span><br/>
    <label>part 2 solution:</label>
    <span id="part-2-output">-</span><br/>
    <br/>
    <canvas id="canvas" width="600" height="600"></canvas>
  </body>
</html>
